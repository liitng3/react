{"version":3,"sources":["Showtime.js","Todolist/Todoinput.js","Todolist/Todoing.js","Todolist/Todolist.js","index.js"],"names":["Component","Todoinput","handleinput","e","keyCode","props","add","target","value","handleChange","setState","name","parseInt","bind","state","inputValue1","inputValue2","inputValue3","console","log","this","focus","ref","inp","onChange","onKeyDown","type","onClick","Todoing","todo","map","item","idx","key","del","defaultProps","Todolist","addItem","data","delItem","splice","a","ReactDOM","render","document","getElementById","className"],"mappings":"iPACuBA,Y,2BCCFC,E,YAEnB,aAAc,IAAD,8BACT,+CASJC,YAAY,SAACC,GACI,KAAZA,EAAEC,SAED,EAAKC,MAAMC,IAAIH,EAAEI,OAAOC,QAbjB,EAiBbC,aAAa,SAACN,GACZ,EAAKO,SAAL,eAEGP,EAAEI,OAAOI,KAAMC,SAA0B,KAAjBT,EAAEI,OAAOC,MAAW,EAAEL,EAAEI,OAAOC,UAlBxD,EAAKN,YAAY,EAAKA,YAAYW,KAAjB,gBACjB,EAAKC,MAAM,CACTC,YAAY,GACZC,YAAY,GACZC,YAAY,IANL,E,iFAwBXC,QAAQC,IAAIC,MACZA,KAAKL,YAAYM,U,+BAET,IAAD,OAEP,OACE,6BAGE,2BAAOC,IAAK,SAACC,GAAO,EAAKR,YAAYQ,GAAMC,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAMC,YAAaU,UAAWL,KAAKlB,YAAawB,KAAK,SAH3I,IAKE,2BAAOf,KAAK,cAAca,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAME,YAAaS,UAAWL,KAAKlB,YAAawB,KAAK,SAL1H,IAOE,2BAAOf,KAAK,cAAca,SAAUJ,KAAKX,aAAcD,MAAOY,KAAKN,MAAMG,YAAaQ,UAAWL,KAAKlB,YAAawB,KAAK,SAP1H,IAUE,2BAAIN,KAAKN,MAAMC,YAAYK,KAAKN,MAAME,YAAYI,KAAKN,MAAMG,aAE7D,gDAIC,2BAAOK,IAAK,SAACC,GAAO,EAAKA,IAAIA,GAAMG,KAAK,SACxC,4BAAQC,QAAS,WAAKT,QAAQC,IAAI,EAAKI,IAAIf,SAA3C,qB,GAjD8BR,aCClB4B,E,iLAIT,IAAD,OACFC,EAAMT,KAAKf,MAAXwB,KACL,OACE,6BACE,4BAEQA,EAAKC,KAAI,SAACC,EAAKC,GACX,OAAO,wBAAIC,IAAKD,GAAMD,EAAf,QAAyB,4BAAQJ,QAAS,SAACxB,GAAD,OAAK,EAAKE,MAAM6B,IAAIF,EAAI7B,KAAzC,0B,GAXfH,aAmCrC4B,EAAQO,aAAa,CACnBN,KAAK,CAAC,EAAE,EAAE,EAAE,EAAE,I,ICnCKO,E,YACnB,aAAc,IAAD,8BACT,+CAMJC,QAAQ,SAACC,GAIP,EAAK5B,SAAS,CACVmB,KAAK,GAAD,mBAAK,EAAKf,MAAMe,MAAhB,CAAqBS,OAZlB,EAebC,QAAQ,SAACP,EAAI7B,GAEXe,QAAQC,IAAIhB,GACZ,IAAI0B,EAAK,YAAI,EAAKf,MAAMe,MACxBA,EAAKW,OAAOR,EAAI,GAEhB,EAAKtB,SAAS,CACVmB,KAAKA,IACP,WACEX,QAAQC,IAAIU,OAtBd,EAAKf,MAAM,CACPe,KAAK,CAAC,EAAE,EAAE,GACVY,EAAE,KAJG,E,sEAiCX,OACE,6BACE,kBAAC,EAAD,CAAWnC,IAAKc,KAAKiB,UADvB,2JAEE,kBAAC,EAAD,CAASH,IAAKd,KAAKmB,QAASV,KAAMT,KAAKN,MAAMe,Y,GArCf7B,aCyQtC0C,IAASC,OACL,kBAAC,EAAD,MACAC,SAASC,eAAe,SAmIlBD,SAASC,eAAe,QAK9BC,UAAY,W","file":"static/js/main.d89a59df.chunk.js","sourcesContent":["import React,{Fragment,Component} from 'react';\r\nclass ShowTime extends Component{\r\n    constructor(props){\r\n        super(props);\r\n        this.state = {\r\n            time: new Date().toLocaleString(),\r\n            a: 100,\r\n            b: 200\r\n        }\r\n        console.log('constructor')\r\n        setTimeout(()=>{\r\n            this.setState({\r\n                time: new Date().toLocaleString()\r\n            })\r\n        },1000)\r\n    }\r\n    shouldComponentUpdate(){\r\n        if(this.state.a>10){\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    componentDidUpdate(preProps,preState,data){\r\n        console.log('didupdate');\r\n        console.log(preState)\r\n        console.log(this.state.time)\r\n    }\r\n    getSnapshotBeforeUpdate(){\r\n        console.log('getSnapshot');\r\n        return {name: this.state.a}\r\n    }\r\n    componentDidMount(){\r\n        console.log('didmount');\r\n    }\r\n    render(){\r\n        console.log('render');\r\n        var {name,age} = this.props;\r\n        return (\r\n            <Fragment>\r\n                {/* 条件渲染 */}\r\n                {name.length>5?<div>姓名：{name}</div>:''}\r\n                {name.length>5&&<div>姓名：{name}</div>}\r\n                <div>{this.state.time}</div>\r\n                {/* 循环渲染 */}\r\n                <div>\r\n                    {\r\n                        age.map((item,index)=>{\r\n                            if(index%2 === 0){\r\n                                return <p key={index}>{item}</p>\r\n                            }\r\n                        })\r\n                    }\r\n                </div>\r\n            </Fragment>\r\n        )\r\n    }\r\n}\r\n//默认导出：只能导出一次，被引入时可以重命名\r\nexport default ShowTime;\r\n\r\n/*\r\n//命名导出：可以导出多个，被引入时与导出的名字一致\r\nexport {ShowTime}\r\nexport const num=100;\r\nexport const num1=100;\r\n//被引用时应使用\r\nimport {ShowTime} from './Showtime';\r\n*/","import React, { Component } from 'react';\r\n\r\nexport default class Todoinput extends Component {\r\n/**大括号里是js环境 */\r\n  constructor(){\r\n      super();\r\n      this.handleinput=this.handleinput.bind(this);\r\n      this.state={\r\n        inputValue1:'',\r\n        inputValue2:'',\r\n        inputValue3:''\r\n      }\r\n\r\n  }\r\n  handleinput=(e)=>{            //改为剪头函数就没有this的问题了\r\n    if(e.keyCode===13){\r\n        // console.log(e.target.value);//e.target表示input中\r\n        this.props.add(e.target.value);\r\n        \r\n    }\r\n  }   \r\n  handleChange=(e)=>{            //改为剪头函数就没有this的问题了\r\n    this.setState({\r\n      //inputValue:e.target.value\r\n      [e.target.name]:parseInt(e.target.value===''?0:e.target.value)\r\n    })\r\n  }      \r\n  componentDidMount(){\r\n    console.log(this);\r\n    this.inputValue1.focus();\r\n  }              \r\n  render() {\r\n    //受控组件：value值被react控制的表单元素,可以实时获取表单元素的值，写法相对麻烦\r\n    return (\r\n      <div>\r\n        {/* <input onKeyDown={this.handleinput} type='text'/> */}\r\n        {/* <input value=\"abc\" onKeyDown={this.handleinput} type='text'/> */}\r\n        <input ref={(inp)=>{this.inputValue1=inp}} onChange={this.handleChange} value={this.state.inputValue1} onKeyDown={this.handleinput} type='text'/>\r\n        +\r\n        <input name='inputValue2' onChange={this.handleChange} value={this.state.inputValue2} onKeyDown={this.handleinput} type='text'/>\r\n        +\r\n        <input name='inputValue3' onChange={this.handleChange} value={this.state.inputValue3} onKeyDown={this.handleinput} type='text'/>\r\n        =\r\n        {/* 在别的地方拿input中的值 */}\r\n        <p>{this.state.inputValue1+this.state.inputValue2+this.state.inputValue3}</p>\r\n        {/* <button onClick={()=>{console.log(this.state.inputValue)}}>提交</button> */}\r\n        <button>提交</button>\r\n\r\n        \r\n         {/* 非受控组件:一次性获取或处理表单元素的值 */}\r\n         <input ref={(inp)=>{this.inp=inp}} type=\"text\"/>\r\n         <button onClick={()=>{console.log(this.inp.value)}}>提交</button>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n// 受控组件：\r\n// 1、给input标签添加value属性，赋值为state的值\r\n// 2、给input标签绑定onChange事件，\r\n// 在事件处理函数中setState\r\n// 3、一个事件处理函数控制多个表单元素时，\r\n// 给input标签加上name属性,事件处理函数中写：\r\n// setState({[e.target.name]:e.target.value})","import React, { Component } from 'react';\r\nimport PropTypes from  'prop-types';\r\n\r\nexport default class Todoing extends Component {\r\n//   delItem=(idx,e)=>{\r\n//     this.props.del(idx);\r\n//   }\r\n  render() {\r\n    var {todo}=this.props;\r\n    return (\r\n      <div>\r\n        <ul>\r\n            {\r\n                todo.map((item,idx)=>{    //map会返回一个数组\r\n                    return <li key={idx}>{item}-----<button onClick={(e)=>this.props.del(idx,e)}>删除</button></li>\r\n                })//{}里是一个值，不是一个语句，里面不要分号       onClick={()=>this.props.del(idx)不可以写成this.props.del(idx)就变成立即执行了,不传参的话就可以直接调用this.props.del了 \r\n            }     \r\n        </ul>\r\n      </div>\r\n    //   <div>\r\n    //     <ul>\r\n    //         {\r\n    //             todo.map((item,idx)=>{    //map会返回一个数组\r\n    //                 return <li key={idx}>{item}-----<button onClick={this.delItem.bind(this,del)}>删除</button></li>\r\n    //             })//{}里是一个值，不是一个语句，里面不要分号       onClick={()=>this.props.del(idx)不可以写成this.props.del(idx)就变成立即执行了,不传参的话就可以直接调用this.props.del了 \r\n    //         }     \r\n    //     </ul>\r\n    //   </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\n//类型检查\r\nTodoing.propTypes={\r\n  todo:PropTypes.array,\r\n  del:PropTypes.func\r\n}\r\nTodoing.defaultProps={\r\n  todo:[1,2,3,4,5]\r\n}\r\n","import React, { Component } from 'react';\r\nimport Todoinput from './Todoinput';\r\nimport Todoing from './Todoing';\r\n\r\nexport default class Todolist extends Component {\r\n  constructor(){\r\n      super();\r\n      this.state={\r\n          todo:[1,2,3],\r\n          a:100  //状态里可以有很多个\r\n      }\r\n  }\r\n  addItem=(data)=>{      //类里面的类方法里面没有this指向，用剪头函数即可\r\n    // this.state.todo.push(data);\r\n    // console.log(this.state.todo);\r\n    //不要对状态进行改变如上，应该用setstate改变里面的内容\r\n    this.setState({    \r\n        todo:[...this.state.todo,data]\r\n    })\r\n  }\r\n  delItem=(idx,e)=>{\r\n    //1.不能直接改变或处理state，通过setstate改变\r\n    console.log(e);//函数声明时事件对象作为最后一个参数传入 \r\n    let todo=[...this.state.todo];//下面操作TODO，而不要直接操作状态\r\n    todo.splice(idx,1);\r\n    //2.setstate是异步执行\r\n    this.setState({    \r\n        todo:todo\r\n    },()=>{\r\n        console.log(todo);\r\n    })\r\n    // this.setState({    \r\n    //     todo:todo\r\n    // })\r\n    // console.log(todo);  会显示删除前的数组\r\n    \r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <Todoinput add={this.addItem}/>       /*add和本页面中的名字没有任何关系，与子页面的有关系*/\r\n        <Todoing del={this.delItem} todo={this.state.todo}/>  \r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n//深拷贝(不同内存)、浅拷贝(同一块内存)\r\n    //   var obj={a:100};\r\n    //   var o={...obj};//一旦引用大括号，就生成了一个新的对象，不影响以前的\r\n    //   o.a=200;\r\n    //   console.log(obj);//任然是100    \r\n\r\n      // var obj={a:100,b:[1,2,3]};\r\n      // var obj1={c:300};\r\n      // //var o={...obj};//一旦引用大括号，就生成了一个新的对象，不影响以前的\r\n      // var o=Object.assign(obj,obj1);\r\n    //   var o=JSON.parse(JSON.stringify(obj));   深拷贝\r\n    //   o.b[0]=200;\r\n      // console.log(o);//任然是100 \r\n      // console.log(o===true);//任然是100  \r\n\r\n      // var o=Object.assign({},obj,obj1); //大括号形成新的对象\r\n      // console.log(o);//任然是100 \r\n      // console.log(o===true);//任然是100   \r\n\r\n    //   Object.keys(obj).forEach((item)=>{\r\n    //       console.log(item)\r\n    //       console,log(obj[item])\r\n    //   });//遍历对象比forin更好用，Object.keys(obj)把对象返回成一个数组","// import React,{Fragment} from 'react';\n// import ReactDOM from 'react-dom';\n// import Showtime from './Showtime.js'\n// import './index.css';\n//import App from './App';\n//import * as serviceWorker from './serviceWorker';\n\n\n//ReactDOM.render(<App />, document.getElementById('root'));\n// var str='react';\n// var ele=<h1 class=\"tit\">hello <p>react</p></h1>;\n// var obj={\n//     type:'h1',\n//     props:{            //props属性\n//         id:\"tit\",\n//         class:\"tit\",\n//         children:[\"hello\"]\n//     }\n\n// }\n// var ele=React.createElement(\"h1\",{id:\"tit\",class:\"tit\"},\"hello\",React.createElement(\"p\",{id:\"t\",class:\"t\"},\"react\"))\n// console.log(ele);\n//ReactDOM.render(ele, document.getElementById('root'));\n\n\n\n// var obj={\n//     type:'h1',\n//     props:{            //props属性\n//         id:\"tit\",\n//         class:\"tit\",\n        \n//     }\n\n// }\n// function render(obj,container){\n//     var ele=document.createElement(obj.type);\n//     for(var item in obj.props){\n//         if(item==='class'){\n//             ele.className=obj.props[item]\n//         }\n//         else{\n//             ele[item]=obj.props[item];    //不可以.item  用中括号才表示item是一个变量\n//         }\n//     }\n//     container.appendChild(ele);\n// }\n// render(obj,document.getElementById(\"root\"));\n\n\n// var obj={\n//     type:'h1',\n//     props:{            //props属性\n//         id:\"tit\",\n//         class:\"tit\",\n//         children:[\"hello\",'react']\n//     }\n\n// }\n// function render(obj,container){\n//     var {type,props}=obj\n//     var ele=document.createElement(type);\n//     for(var item in props){\n//         if(item==='class'){\n//             ele.className=props[item]\n//         }\n//         else if(item==='children'){\n//             for(var i=0;i<props[item].length;i++){\n//                 //ele.innerHTML+=props.children[i];\n//                 var txt=document.createTextNode(props.children[i]);\n//                 ele.appendChild(txt);\n//             }\n//         }\n//         else{\n//             ele[item]=props[item];    //不可以.item  用中括号才表示item是一个变量\n//         }\n//     }\n//     container.appendChild(ele);\n// }\n// render(obj,document.getElementById(\"root\"));\n\n\n\n\n\n\n\n\n\n// //自己封装render\n// var obj={\n//     type:'div',\n//     props:{            //props属性\n//         id:\"tit\",\n//         class:\"tit\",\n//         children:[\"hello\",'react',\n//             {\n//                 type:'h1',\n//                 props:{            //props属性\n//                     id:\"tit\",\n//                     class:\"tit\",\n//                     children:[\"hello\",'react']\n//             }\n        \n//         }]\n//     }\n\n// }\n// function render(obj,container){\n//     var {type,props}=obj\n//     //文档碎片               相当于一个虚拟的节点，承载节点里面的东西\n//     var fragment=document.createDocumentFragment();\n//     var ele=document.createElement(type);\n//     for(var item in props){\n//         if(item==='class'){\n//             ele.className=props[item]\n//         }\n//         else if(item==='children'){\n//             for(var i=0;i<props[item].length;i++){\n//                 //ele.innerHTML+=props.children[i];\n//                 if(typeof props.children[i]==='object'){\n//                     render(props.children[i],ele);\n//                 }else{\n//                     var txt=document.createTextNode(props.children[i]);\n//                     ele.appendChild(txt);\n//                 }\n//             }\n//         }\n//         else{\n//             ele[item]=props[item];    //不可以.item  用中括号才表示item是一个变量\n//         }\n//     }\n//     fragment.appendChild(ele)\n//     container.appendChild(fragment);\n// }\n// //render(obj,document.getElementById(\"root\"));\n\n// //页面渲染过程\n// //请求HTML页面、浏览器HTML解析器解析成HTML文件，生成dom树\n// //link引入CSS文件、CSS解析器解析CSS，生成CSS对象模型，CSSOM和DOM tree结合生成一个渲染书render tree\n\n\n// //页面回流（重排reflow）：DOM结构(删除增加)发生变化、内容变化、大小位置的变化、显示的变化(display，none)就会把页面重新解析渲染一遍(渲染过程如上),消耗性能，回流的代价很大\n// //页面重绘（repaint）：颜色的变化(背景色、字体颜色、边框颜色)只会把这一小部分再渲染一遍\n\n\n\n// //1.dom结构发生变化-----------先用变量进行DOM处理，最后一次渲染\n\n// //会引起很多次回流，造成性能消耗\n// console.time('time');\n// var div=document.getElementById(\"root\");\n// var str=''\n// for(var i=0;i<1000;i++){\n//     div.innerHTML+='<p>'+i+'</p>';\n// }\n// console.timeEnd('time');\n\n// //下面只会引起一次回流\n// console.time('time');\n// var div=document.getElementById(\"root\");\n// var str=''\n// for(var i=0;i<1000;i++){\n//     str+='<p>'+i+'</p>';\n// }\n// div.innerHTML=str;\n// console.timeEnd('time');\n\n\n// //2.对于样式的处理\n\n// //会引起很2次回流和1次重绘，造成性能消耗\n// var div=document.getElementById(\"root\");\n// div.style.width='100px';\n// div.style.height='100px';\n// div.style.backgroundColor='red';\n\n// //下面只会引起一次回流和重绘\n// var div=document.getElementById(\"root\");\n// div.className='active';\n\n\n\n// //3.offsetLeft/offsetWidth等都会引起回流   尽量少些使用\n// console.log(div.offsetLeft);\n\n// //会引起多次回流，消耗性能\n// var wid=div.offsetWidth\n// setInterval(()=>{\n//     wid+=1;\n//     div.style.width=wid+'px';\n// },100)\n\n// //减少回流\n// var wid=div.offsetWidth\n// setInterval(()=>{\n//     wid+=1;\n//     div.style.width=wid+'px';\n// },100)\n\n\n// //4.文档碎片(内存中的一个变量)\n\n\n\n// //显示当前系统时间\n// function showTime(){\n//     var ele= <div>{new Date().toLocaleString()}</div>;\n//     ReactDOM.render(\n//         ele,\n//         document.querySelector('#root')\n//     );\n// }\n// showTime();\n// setInterval(showTime,1000);\n\n\n\n// //函数声明组件\n// function Showtime(props){\n//     console.log(props);\n//     //return 中只可以最终返回一个封闭标签   如下会出错\n//     // return (                           \n//     //     <div></div>\n//     //     <div>\n//     //         {props.name}{new Date().toLocaleString()}\n//     //     </div>\n//     // )\n\n//     // return (<div>                            \n//     //         <div></div>\n//     //         <div>\n//     //             {props.name}{new Date().toLocaleString()}\n//     //         </div>\n//     //         </div>\n//     //     )\n\n\n//     //这样节省了DOM节点的使用\n//     return (<Fragment>             \n//         <div>{props.name}</div>\n//         <div>{new Date().toLocaleString()}</div>\n//         </Fragment>  \n//     )\n    \n// }\n\n\n// var num=[1,2,3,4,5];\n// ReactDOM.render(\n//     <Showtime name=\"zhangsan\" age={num}/>,     //引用变量要用大括号\n//     document.getElementById(\"root\")\n// );\n\n\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\n// serviceWorker.unregister();\n\n\nimport React,{Fragment,Component} from 'react';\nimport ReactDOM from 'react-dom';\nimport ShowTime from './Showtime';    //引用js文件时可以省略.js    其他文件不可以\nimport './index.css';\nimport Todolist from './Todolist/Todolist';\n\nReactDOM.render(\n    <Todolist/>,\n    document.getElementById('root')\n)\n\n\n//***************************组件的首字母一定要大写，创建文件名称时要注意***************************\n\n\n// 函数声明组件\n// function ShowTime(props){\n//     console.log(props);\n//     return (<Fragment>\n//                 <div>{props.name}{props.age}</div>\n//                 <div>\n//                     {new Date().toLocaleString()}\n//                 </div>\n//             </Fragment>\n//         )\n// }\n\n// 类定义组件\n\n\n// var num = [1,2,3,4,5];\n// ReactDOM.render(\n//     <ShowTime age={num} name=\"zhangsan\"/>,\n//     document.getElementById('root')\n// )\n\n\n\n\n\n// 显示当前系统时间\n// function showTime(){\n//     var ele = <div>\n//                 <p>当前时间是：</p>\n//                 <div>{new Date().toLocaleString()}</div>;\n//             </div>;\n//     ReactDOM.render(\n//         ele,\n//         document.querySelector('#root')\n//     );\n// } \n// showTime();\n// setInterval(showTime,1000);\n\n\n\n\n\n// react技术栈\n// jsx语法\n// var ele = <h1 class=\"tit\">hello <p>react</p></h1>;\n// babel编译，返回一个对象\n// var ele = React.createElement(\n//     'h1',\n//     {id:'tit',class:'title'},\n//     'hello',\n//     React.createElement(\n//         'p',\n//         {id:'t',class:'tit'},\n//         'react')\n// );\n// ReactDOM.render(ele, document.getElementById('root'));\n// 自己封装render函数\n// var obj = {\n//     type: 'div',\n//     props: {\n//         id: 'box',\n//         class: 'box',\n//         children: [\n//             'hello',\n//             'react',\n//             {\n//                 type: 'h1',\n//                 props: {\n//                     id: 'tit',\n//                     class: 'tit',\n//                     children: [\n//                         'title',\n//                         'react'\n//                     ]\n//                 }\n//             }\n//         ]\n//     }\n// }\n// function render(obj,container){\n//     var {type,props} = obj;\n//     // 文档碎片\n//     var fragment = document.createDocumentFragment();\n\n//     var ele = document.createElement(type);\n//     for(var item in props){\n//         if(item === 'class'){\n//             ele.className = props[item]\n//         }else if(item === 'children'){\n//             for(var i=0;i<props.children.length;i++){\n//                 // ele.innerHTML += props.children[i];\n//                 if(typeof props.children[i] === 'object'){\n//                     render(props.children[i],ele);\n//                 }else{\n//                     var txt = document.createTextNode(props.children[i]);\n//                     ele.appendChild(txt);\n//                 }\n//             }\n//         }else{\n//             ele[item] = props[item];\n//         }\n//     }\n//     fragment.appendChild(ele);\n//     container.appendChild(fragment);\n// }\n// render(obj,document.getElementById('root'));\n// 页面渲染过程\n// 请求HTML页面、浏览器HTML解析器解析html文件、生成DOM树\n// link引入css文件、css解析器解析CSS，生成CSS对象模型，CSSOM和DOM tree结合生成一个render tree，最后浏览器绘制页面\n\n// 页面回流（重排reflow）：DOM结构变化、内容变化、大小、位置的变化、显示的变化\n// 页面重绘（repaint）：颜色的变化（背景色、字体颜色、边框颜色）\n\n// 1、先用变量进行dom处理，最后一次渲染\n// console.time('time');\n// var div = document.getElementById('root');\n// var str = ''\n// for(var i=0;i<1000;i++){\n//     str += '<p>'+i+'</p>';\n// }\n// div.innerHTML = str;\n// console.timeEnd('time');\n// 2、对于样式处理,声明一个css类\nvar div = document.getElementById('root');\n// div.style.width = '100px';\n// div.style.height = '100px';\n// div.style.background = 'red';\n\ndiv.className = 'active';\n// 3、offsetLeft、offsetWidth等都会引起回流，要慎用\n// console.log(div.offsetLeft);\n// var wid = div.offsetWidth;\n// setInterval(()=>{\n//     wid += 1;\n//     div.style.width = wid + 'px';\n// },100)\n// 4、文档碎片（内存中的一个变量）\n\n\n\n//组件交互\n//父组件---->子组件：调用子组件时添加属性，子组件通过props拿到传递的数据\n//子组件---->父组件：\n"],"sourceRoot":""}